<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">


<html>

<head>

    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>YDF2 - Writing your first application</title>
    <link href="api/doxygen.css" rel="stylesheet" type="text/css">

</head>

<body>

    <h1>Yellow Duck Framework </h1>

    <h3 align="center">version 2.0.0 </h3>

    <hr size="1" noshade>
    <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
        <td align="left" width="40%">
            [ <a href="tutorial_01.html">previous</a> ]
            <br>
            <font size="-1"><i>Installing the Yellow Duck Framework</i></font>
        </td>
        <td align="center" width="20%" valign="top">
            [ <a href="index.html">contents</a> ]
        </td>
        <td align="right" width="40%">
            [ <a href="tutorial_03.html">next</a> ]
            <br>
            <font size="-1"><i>How requests are processed</i></font>
        </td>
    </tr>
    </table>
    <hr size="1" noshade>

    <h3>3. Writing your first application</h3>

    <hr size="1" noshade>

    <p><b>Description of the application</b></p>

    <p>The sample application we are going to use is a simple notebook which has
    three options. The following options are supported by our notebook:</p>

    <ul>
        <li>Showing the list of notes (default)</li>
        <li>Adding a note</li>
        <li>Deleting a note</li>
    </ul>

    <p>After you finished this part, the finished example application will look
    like this:</p>

    <p><img src="tutorial_02_001.gif" border="0" width="553" height="381"></p>

    <p>The interface for adding a new note will look as follows:</p>

    <p><img src="tutorial_02_002.gif" border="0" width="553" height="381"></p>

    <p>The delete screen doesn't really have a user interface. It will remove
    the item from the list and reload the list once that is done.</p>

    <p><b>Note:</b> In order no to over complicate this example, we will store
    the notes as files on the disk instead of using a database.</p>


    <p>&nbsp;<br><b>Structuring the application</b></p>

    <p>Before you start writing the actual code, you need to do a little bit of
    planning and determine which actions you will create to make your
    application work. In our case, we are going to make 3 different actions:</p>

    <ul>
        <li>
            <b>default:</b> this is the default action and will show the list of
            notes. If no notes are found, it should tell us so.
            <br>&nbsp;
        </li>
        <li>
            <b>addnote:</b> this action will take care of adding a new note. It 
            will render the form you need to fill in, but it will also take care
            of handling the form correctly and saving the result to disk.
            <br>&nbsp;
        </li>
        <li>
            <b>deletenote:</b> this function will delete a note based on it's 
            unique ID. In this example, it will not ask you for confirmation,
            but it will simply delete the note.
        </li>
    </ul>

    <p>Now that we know what actions the application will be able to perform, we
    now need to think about how we can store the notes on disk. We will create
    an associative array for each note which will contain the title, body and
    the unique ID for the entry.</p>

    <p>The unique ID for an entry will be created by calculating the md5
    checksum of the combination of the title and the body. This will ensure that
    each note is unique.</p>

    <p><b>Note:</b> the example will not warn about the fact that a duplicate
    entry was entered. It will just overwrite the existing one. I'll leave it
    up to you to implement that yourself after finishing this chapter.</p>

    <p>We will use the functions provided by the Yellow Duck Framework to load
    the notes from disk and save the notes to disk. In the framework, there are
    different objects and functions that take care of this.</p>

    <p>After going through this example, you will have used and explored the
    following classes and modules in the Yellow Duck Framework:</p>

    <ul>
        <li>YDRequest (class)</li>
        <li>YDFSDirectory (class)</li>
        <li>YDFSFile (class)</li>
        <li>YDForm (class)</li>
        <li>YDObjectUtil (module)</li>
    </ul>


    <p>&nbsp;<br><b>Before we continue</b></p>

    <p>Before we continue, you need to make sure the Yellow Duck Framework is
    properly installed and working correctly. Installation instructions can be
    found in <a href="tutorial_01.html"><i>2. Installing the Yellow Duck
    Framework</i></a>.</p>


    <p>&nbsp;<br><b>Creating the directory and the files</b></p>

    <p>To start, create a new folder in your webroot called "firstapp". We will
    store all the files related to this tutorial in that folder.</p>

    <p>In this folder, we will need to create two files for our application. We
    need 1 file called "index.php", which will contain the actual script that
    drives the application. We will also need a file which is called "index.tpl"
    which contains the template for this application. The template will define
    how the application will be presented in the browser.</p>

    <p>By separating the actual script from the presentation, we will make the
    application a lot easier to maintain and understand. By using this
    structured way, it will be a lot easier to track down problems because you
    know immediately where to look.</p>


    <p>&nbsp;<br><b>Implementing the basis of the index.php file</b></p>

    <p>The first thing we will do is to implement the basic stuff of the
    index.php script. As you could read in the first chapter, the name of
    the file determines how the class should be named.</p>

    <p>Open the index.php file in a text editor and enter the following
    text in the file:</p>

    <b>Source: index.php</b><br>
<pre class="fragment"><span class="comment">// Initialize the Yellow Duck Framework</span>
require_once( dirname( __FILE__ ) . '/YDFramework2/YDF2_init.php' );

<span class="comment">// Includes</span>
require_once( 'YDRequest.php' );
require_once( 'YDFSDirectory.php' );
require_once( 'YDObjectUtil.php' );
require_once( 'YDForm.php' );

<span class="comment">// Class definition for the index request</span>
class indexRequest extends YDRequest {

    <span class="comment">// Class constructor</span>
    function indexRequest() {

        <span class="comment">// Initialize the parent class</span>
        $this-&gt;YDRequest();

    }

    <span class="comment">// Default action</span>
    function actionDefault() {
    }

    <span class="comment">// Add Note action</span>
    function actionAddNote() {
    }

    <span class="comment">// Delete Note action</span>
    function actionDeleteNote() {
    }

}

<span class="comment">// Process the request</span>
require_once( dirname( __FILE__ ) . '/YDFramework2/YDF2_process.php' );</pre>

    <p>There are a number of rules to follow to get the basis of the class
    implemented. Let's go over each one of them:</p>

    <ul>
        <li>
            <b>Include the init file:</b> each script that wants to use the
            Yellow Duck Framework needs to include the "YDF2_init.php" file 
            which initializes the framework. Make sure the path to this file is 
            correct, otherwise, the script will not work.
            <br>&nbsp;
        </li>
        <li>
            <b>Include the needed classes:</b> The next step is to include all
            the different classes from the framework you are going to use. I
            used the require_once to make sure the script doesn't continue
            without having included these files. You don't need to specify the 
            complete path to these files as the framework will take care of 
            finding the right files.
            <br>&nbsp;
        </li>
        <li>
            <b>Define the main class:</b> each script that wants to use the
            Yellow Duck Framework needs to have a class which is named after the
            name of the file. In our example, the file is named "index.php",
            which means the framework will search for a class called
            "indexRequest". This class needs to extends the YDRequest class
            to allow the framework to process the request.
            <br>&nbsp;
        </li>
        <li>
            <b>Define the class constructor:</b> When the instance of our class 
            is created, it will execute the function which has the same name as 
            the class automatically (this function is called the <i>class 
            constructor</i>). In the class constructor, we simply call the
            YDRequest function (which is the class constructor from the 
            YDRequest class) to make sure the parent class is initialized as 
            well.
            <br>&nbsp;
        </li>
        <li>
            <b>Define the functions for the actions:</b> For each action, we
            need to create a separate function in the class. Each function for 
            an action has the name of the action prepended by "action" as it's 
            function name. By default, these function do not require any 
            arguments.
        </li>
    </ul>

    <p>With this implemented, you can already surf to the index.php page, but
    nothing will be shown. You can try the following URLs:</p>

<pre class="fragment">http://localhost/firstapp/index.php
http://localhost/firstapp/index.php?do=addnote
http://localhost/firstapp/index.php?do=deletenote
http://localhost/firstapp/index.php?do=oops</pre>

    <p>If you typed in everything correctly, only the last URL should return
    an error because it's pointing to an undefined action in our class.</p>


    <p>&nbsp;<br><b>Improving the class constructor</b></p>

    <p>We will add one thing to the class constructor, which is a reference
    to the data directory. Before you add the code, make a new folder called
    "data" in the "firstapp" folder. Also make sure that the webserver process
    can write into that directory. On unix systems, you can do this with the
    following shell command:</p>

    <pre class="fragment">/home/pieter # <b>chmod 777 data</b></pre> 

    <p>Once you did that, add the following code to the class constructor:</p>

<pre class="fragment"><span class="comment">// Set the path to the data directory</span>
$this->dataDir = new YDFSDirectory( dirname( __FILE__ ) . '/data/' );</pre>

    <p>With this code, we create a new YDFSDirectory class which represents a 
    folder on disk. We define it specifically create it in the class constructor
    to ensure that all the actions are able to use this object (each action
    needs this).</p>

    <p>Later on, we will see that we can use this object to get a directory
    listing, but we will also  use it to delete and create new files.</p>


    <p>&nbsp;<br><b>Implementing the default action</b></p>

    <p>We will now implement the default action. Add the following code to the
    function actionDefault:</p>

<pre class="fragment"><span class="comment">// Default action</span>
function actionDefault() {

    <span class="comment">// Start with an empty list of entries</span>
    $entries = array();

    <span class="comment">// Loop over the data directory contents</span>
    foreach( $this->dataDir->getContents( '*.dat' ) as $entry ) {

        <span class="comment">// Get the contents</span>
        $entry = $entry->getContents();

        <span class="comment">// Unserialize</span>
        $entry = YDObjectUtil::unserialize( $entry );

        <span class="comment">// Add it to the list of entries</span>
        array_push( $entries, $entry );

    }

    <span class="comment">// Add the entries to the template</span>
    $this->setVar( 'entries', $entries );

    <span class="comment">// Output the template</span>
    $this->outputTemplate();

}</pre>

    <p>The code of this function is pretty self explanatory. Let's go over
    each line to see what it does:</p>

    <ul>
        <li>
            <pre class="fragment">$entries = array();</pre>
            This line creates a new array which will use to store the entries in.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">foreach( $this->dataDir->getContents( '*.dat' ) as $entry ) {</pre>
            This line line will query the data directory and get a YDFSFile 
            object for each file that ends with the extension "dat". The
            getContents function always returns objects.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$entry = $entry->getContents();</pre>
            This line line will replace the variable $entry with the contents of
            our YDFSFile object.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$entry = YDObjectUtil::unserialize( $entry );</pre>
            Since the entries are <i>serialized</i>, we need to 
            <i>unserialize</i> them to get the original object back. The 
            YDObjectUtil::unserialize function will take care of this.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">array_push( $entries, $entry );</pre>
            We now have the original object back, which we will just add to the
            list of entries.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$this->setVar( 'entries', $entries );</pre>
            When a new YDRequest class is instantiated, automatically a new 
            template object is created. You can then use the setVar function 
            from the YDRequest class to assign variables to the template. We add 
            a new template variable called "entries" which holds the list of 
            entries.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$this->outputTemplate();</pre>
            The last step is to parse the template and output it to the browser.
            Since we didn't specify the name of the template, it will look for a 
            file with the same name as the script, but which has the extension 
            "tpl" instead of "php". It will parse the template and send the 
            result to the browser.
            <br>&nbsp;
        </li>
    </ul>

    <p>If you run the script now in the browser, you will see an empty screen, 
    and no errors should be shown. You don't see anything yet since the template
    is still an empty file.</p>


    <p>&nbsp;<br><b>Implementing the template</b></p>

    <p>Now that we have the default action implemented, we will change the 
    template so that it shows the list of notes which it should do. Here's is 
    how the template looks like to show the list of entries:</p>

<pre class="fragment">&lt;html&gt;

&lt;head&gt;

    &lt;title&gt;&lt;?= $YD_FW_NAMEVERS ?&gt;&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;

    &lt;?php if ( $YD_ACTION == 'default' ) { ?&gt;

        &lt;h3&gt;Notes&lt;/h3&gt;

        &lt;p&gt;&lt;a href="&lt;?= $YD_SELF_SCRIPT ?&gt;?do=AddNote"&gt;Add a new note&lt;/a&gt;&lt;/p&gt;

        &lt;?php if ( $entries ) { ?&gt;

            &lt;?php foreach ( $entries as $entry ) { ?&gt;
                &lt;p&gt;
                &lt;b&gt;&lt;?= $entry['title'] ?&gt;&lt;/b&gt;
                [ &lt;a href="&lt;?= $YD_SELF_SCRIPT ?&gt;?do=DeleteNote&id=&lt;?= $entry['id'] ?&gt;"&gt;delete&lt;/a&gt; ]
                &lt;br&gt;
                &lt;?= $entry['body'] ?&gt;
                &lt;/p&gt;
            &lt;?php } ?&gt;

        &lt;?php } else { ?&gt;
            &lt;p&gt;No notes were found.&lt;/p&gt;
        &lt;?php } ?&gt;

    &lt;?php } ?&gt;

&lt;/body&gt;

&lt;/html&gt;</pre>

    <p>The first thing we do in the template is to check if we are running the
    default action. Since we are going to combine the templates for all the
    different actions, we need to make sure we only show the parts relevant for
    the current action.</p>

    <p>As you can see, this is a plain PHP script which only contains the code 
    needed to display the list. As you can see, we can reference the variables
    as normal PHP variables and show their contents.</p>

    <p>We also use some special variables in the script that are automatically
    added to the template by the framework. We use the following ones:</p>

    <ul>
        <li>
            <b>$YD_FW_NAMEVERS:</b> 
            the name and the version of the framework.
        </li>
        <li>
            <b>$YD_ACTION:</b> 
            the name of the current action (always in lowercase).
        </li>
        <li>
            <b>$YD_SELF_SCRIPT:</b> 
            the url of the script itself without parameters
        </li>
    </ul>

    <p>If you run the script now, it should tell you that no notes were found,
    as we didn't create any yet. There should also be a link that you can use to 
    add a new entry. The next step is to create the form to add a new entry.</p>


    <p>&nbsp;<br><b>Implementing the addnote action</b></p>

    <p>The next step is to implement the action that will take care of adding
    new items. Add the following code to the actionAddEntry function to do 
    this:</p>

<pre class="fragment"><span class="comment">// Add Note action</span>
function actionAddNote() {

    <span class="comment">// Create the add form</span>
    $form = new YDForm( 'addEntryForm' );

    <span class="comment">// Add the elements</span>
    $form->addElement( 'text', 'title', 'Title:' );
    $form->addElement( 'textarea', 'body', 'Contents:' );
    $form->addElement( 'submit', 'cmdSubmit', 'Save' );

    <span class="comment">// Apply filters</span>
    $form->applyFilter( 'title', 'trim' );
    $form->applyFilter( 'body', 'trim' );

    <span class="comment">// Add a rule</span>
    $form->addRule( 'title', 'Title is required', 'required' );
    $form->addRule( 'body', 'Contents is required', 'required' );

    <span class="comment">// Process the form</span>
    if ( $form->validate() ) {

        <span class="comment">// Save the entries in an array</span>
        $entry = array(
            'id' => md5(
                $form->exportValue( 'title' ) . $form->exportValue( 'body' )
            ),
            'title' => $form->exportValue( 'title' ),
            'body' => $form->exportValue( 'body' )
        );

        <span class="comment">// Save the serialized entry to a file</span>
        $this->dataDir->createFile(
            $entry['id'] . '.dat', YDObjectUtil::serialize( $entry )
        );

        <span class="comment">// Forward to the list view</span>
        $this->forward( 'default' );

        <span class="comment">// Return</span>
        return;

    }

    <span class="comment">// Add the form to the template</span>
    $this->addForm( 'form', $form );


    <span class="comment">// Output the template</span>
    $this->outputTemplate();

}</pre>

    <p>This action does two separate things. It knows how to show the form which
    is used to add a new note, and it also knows how to save a note to a file on
    disk which can be retrieved later on.</p>

    <p>Let's evaluate this action step by step:</p>

    <ul>
        <li>
            <pre class="fragment">$form = new YDForm( 'addEntryForm' );</pre>
            This will create a new form object called "addEntryForm". We will
            assign elements to this object to construct the whole form.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$form->addElement( 'text', 'title', 'Title:' );
$form->addElement( 'textarea', 'body', 'Contents:' );
$form->addElement( 'submit', 'cmdSubmit', 'Save' );</pre>
            Now we add three elements to the form. We add a text element called
            "title", a textarea called "body" and a submit button called 
            "cmdSubmit". For each of these elements, we also specify a label.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$form->applyFilter( 'title', 'trim' );
$form->applyFilter( 'body', 'trim' );</pre>
            To the title and body field, we also add a filter called "trim". The
            trim filter will remove all spaces at the beginning and the end of
            the form values before validating the form. We do this to make sure
            that e.g. if the title would be just a space, it wouldn't be
            considered as being valid.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$form->addRule( 'title', 'Title is required', 'required' );
$form->addRule( 'body', 'Contents is required', 'required' );</pre>
            For the validation, we add two rules. With these two rules, we mark
            the elements title and body as required elements. We also specify
            the error message in case the validation fails.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$this->addForm( 'form', $form );</pre>
            This function will assign the form object to the template. Please
            note that we didn't use the setVar function, but used the addForm
            function instead. We need to use this function because the form
            object needs some special treatment before it can be used in the
            template. Never use the setVar function to assing a form object to 
            the template.
            <br>&nbsp;
        </li>
        <li>
            <pre class="fragment">$this->outputTemplate();</pre>
            The last step is to parse and output the template which is done by
            executing the outputTemplate function.
            <br>&nbsp;
        </li>
    </ul>

    <p><b>Note:</b> I specifically didn't explain the part which save the note
    to a file, as it's not important yet. You first need to understand how this
    works before we can add the code for saving the note to disk.</p>

    <p>Before you can run the form, we need to add the code for the form
    to the template. Add the following stuff just before the "&lt;/body&gt;" tag
    in the template:</p>

<pre class="fragment">&lt;?php if ( $YD_ACTION == 'addnote' ) { ?&gt;

    &lt;h3&gt;Add a new note&lt;/h3&gt;

    &lt;?php if ( $form['errors'] ) { ?&gt;
        &lt;p style="color: red"&gt;&lt;b&gt;Errors during processing:&lt;/b&gt;
            &lt;?php foreach ( $form['errors'] as $error ) { ?&gt;
                &lt;br&gt;&lt;?= $error ?&gt;
            &lt;?php } ?&gt;
        &lt;/p&gt;
    &lt;?php } ?&gt;

    &lt;form &lt;?= $form['attributes'] ?&gt;&gt;
        &lt;p&gt;
            &lt;?= $form['title']['label'] ?&gt;
            &lt;br&gt;
            &lt;?= $form['title']['html'] ?&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;?= $form['body']['label'] ?&gt;
            &lt;br&gt;
            &lt;?= $form['body']['html'] ?&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;?= $form['cmdSubmit']['html'] ?&gt;
        &lt;/p&gt;
    &lt;/form&gt;

&lt;?php } ?&gt;</pre>

    <p>If we a look at that code, we see that it will only be shown if the
    current action is called "addnote" (always in lowercase!). The first part
    will take care of showing the errors if there are any.</p>
    
    <p>The errors are always found in the $form['error'] array. this array is
    just a list of all the different error messages. In this example, we use a 
    little but of stylesheets to make them appear in red.</p>

    <p>Then, the code for the form itself is added. We first define the form
    tag, and use the $form['attributes'] variable to automatically add all the
    parameters of the form such as the action and method. The framework is smart
    enough to take care of that automatically.</p>

    <p>Then we will add the different elements. Each element can be referenced
    as $form[<i>elementname</i>]. In this example, we use the label and html
    properties of each element. The label property contains the label as
    specified when you created the form object. The html property contains the
    HTML version of the element.</p>

    <p>This is the only code we need to add for the form. The framework will
    take care of remembering what was entered in each field and displays it when
    needed. It will also take care of the error messages.</p>

    <p>Now that we have the basis of the form, you can surf to the index.php
    page and see what happens. If you submit the form, you will see that the
    values are remembered accross submits, and that the right errors are raised
    if the input was not valid.</p>

    <p>Let's examine the code that saves the entry to disk. We'll go over it
    step by step.</p>

    <ul>
        <li>
            <pre class="fragment">if ( $form->validate() )</pre>
            With this, we can check if the form was validated succesfully. The
            form is only validated when all the validation rules were 
            passed.</p>
        </li>
        <li>
            <pre class="fragment">$entry = array(
    'id' => md5(
        $form->exportValue( 'title' ) . $form->exportValue( 'body' )
    ),
    'title' => $form->exportValue( 'title' ),
    'body' => $form->exportValue( 'body' )
);</pre>
            This code will create a new associative array with the information
            of the entry. We can use the form's exportValue function to get the
            value of a specific field of the form. We used the md5 function to
            create the unique ID for the entry.</p>
        </li>
        <li>
            <pre class="fragment">$this->dataDir->createFile(
    $entry['id'] . '.dat', YDObjectUtil::serialize( $entry )
);</pre>
            The next line does two things. First, it will serialize the array of
            the object. This means it's converted into code which can be saved
            to a file, and which can be read later on again to get the original
            array back. This function is part of the YDObjectUtil module. After
            we have the array as a serialized item, we can use the createFile
            function from the YDFSDirectory object to dump it to a file. The 
            file name will be the id of the entry with the extension "dat".</p>
        </li>
        <li>
            <pre class="fragment">$this->forward( 'default' );</pre>
            Now that the note is saved to disk, we need to show the list of
            notes again. We have two options here. Either you do a redirect,
            which will redirect you to the url of the default action, but this
            requires two HTTP interactions. A lot faster is to forward the
            execution to a different action. The difference is that forwarding
            happens in the same request.</p>
        </li>
        <li>
            <pre class="fragment">return;</pre>
            It's very important to add the return statement, since otherwise,
            the form will be displayed again.
        </li>
    </ul>

    <p><b>Note:</b> one could say that instead of forwarding the request to a
    different action, you could just call the function for that action. 
    Unfortunately, that doesn't work, since the framework will not know that the
    current action has been changed.</p>

    <p>If you run the script now, you will be able to add notes and display 
    them. Also try to add a note without a title or description, and check that
    it is showing the right errors. Also check the contents of the data
    directory to see that the entries are correctly saved in there.</p>


    <p>&nbsp;<br><b>Implementing the deletenote action</b></p>

    <p>To finish off, we will create the action that can delete a note. This
    action will take 1 parameter from the URL, which is called ID. This entry
    will contain the unique ID of the entry.</p>

    <p>To implement this action, add the following code to the actiondeletenote
    function:</p>

    <pre class="fragment"><span class="comment">// Delete note action</span>
function actionDeleteNote() {

    <span class="comment">// Delete the file related to the entry</span>
    $this-&gt;dataDir-&gt;deleteFile( $_GET['id'] . '.dat' );

    <span class="comment">// Forward to the list view</span>
    $this-&gt;forward( 'default' );

}</pre>

    <p>Let's go over this action to see how it works:</p>

    <ul>
        <li>
            <pre class="fragment">$this-&gt;dataDir-&gt;deleteFile( $_GET['id'] . '.dat' );</pre>
            With the deleteFile function from the YDFSDirectory object, we can
            delete the file for this specific note. We find the id of the note
            in the $_GET['id'] variable, which was passed with the URL.
        </li>
        <li>
            <pre class="fragment">$this-&gt;forward( 'default' );</pre>
            After the deletion of the file, we just forward the request to the 
            default action again to show the list of the notes.
        </li>
    </ul>

    <p>After adding this code, you can run the sample again and try to delete a
    note. If you delete the note, it should disappear from the list and the
    file should also be removed from the data directory.</p>

    <p><b>Note:</b> there are some functions that could be added to this action.
    First, it could check if there was an ID given or not. If not, you could
    forward the request to the default action, or you could show an error
    message. You could also add some checking to see if the entry exists or not
    before deleting it. Another option is to add a confirmation screen to
    prevent that someone accidently deletes a note.</p>


    <p>&nbsp;<br><b>The complete application</b></p>

    <p>You will find a complete working copy of this application in the firstapp
    folder inside the examples folder of the Yellow Duck Framework distribution.
    </p>

    <hr size="1" noshade>
    <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
        <td align="left" width="40%">
            [ <a href="tutorial_01.html">previous</a> ]
            <br>
            <font size="-1"><i>Installing the Yellow Duck Framework</i></font>
        </td>
        <td align="center" width="20%" valign="top">
            [ <a href="index.html">contents</a> ]
        </td>
        <td align="right" width="40%">
            [ <a href="tutorial_03.html">next</a> ]
            <br>
            <font size="-1"><i>How requests are processed</i></font>
        </td>
    </tr>
    </table>
    <hr size="1" noshade>

    <address><small>
        Yellow Duck Framework 2.0.0 by Pieter Claerhout,
        <a href="mailto:pieter@yellowduck.be">pieter@yellowduck.be</a>
    </small></address>

</body>

</html>
